name: Linux-XFCE-RDP-Persistent

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write

env:
  RDP_USER: ${{ secrets.RDP_USERNAME || 'RunnerAdmin' }}
  RDP_PASS: ${{ secrets.RDP_PASSWORD || 'SecureP@ssw0rd!2024' }}
  SAVE_RUNTIME: ${{ secrets.SAVE_RUNTIME || 'true' }}
  IDLE_TIMEOUT_MIN: ${{ secrets.IDLE_TIMEOUT_MIN || '3' }}

jobs:
  secure-rdp:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      # ═══════════════════════════════════════════════════════════════
      # STEP 1: PROVISION DISTRIBUTED STATE INFRASTRUCTURE
      # ═══════════════════════════════════════════════════════════════
      - name: Provision Distributed State Infrastructure (Primary/Fallback Routing)
        env:
          DB_PAT: ${{ secrets.BACKUP_DB_PAT }}
          DB_USER: ${{ secrets.BACKUP_DB_USER }}
          DB_REPO: ${{ secrets.BACKUP_DB_REPO }}
          NATIVE_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LOCAL_REPO: ${{ github.repository }}
        run: |
          STATE_DIR="/opt/state-repo"
          FALLBACK=false

          if [ -z "$DB_PAT" ] || [ -z "$DB_USER" ] || [ -z "$DB_REPO" ]; then
              echo "::warning::External database secrets missing. Routing to local repository..."
              FALLBACK=true
          else
              echo "Authenticating to Primary Database: ${DB_USER}/${DB_REPO}"
              REPO_URL="https://${DB_USER}:${DB_PAT}@github.com/${DB_USER}/${DB_REPO}.git"

              if ! git clone -q "$REPO_URL" "$STATE_DIR" 2>/dev/null; then
                  echo "::error::Access to primary database denied or repository empty. Routing to fallback..."
                  FALLBACK=true
              else
                  echo "Primary database connection established."
              fi
          fi

          if [ "$FALLBACK" = true ]; then
              rm -rf "$STATE_DIR" 2>/dev/null || true
              echo "Cloning fallback state database: ${LOCAL_REPO}"
              LOCAL_URL="https://x-access-token:${NATIVE_TOKEN}@github.com/${LOCAL_REPO}.git"

              if ! git clone -q "$LOCAL_URL" "$STATE_DIR" 2>/dev/null; then
                  echo "::error::CRITICAL: Fallback architecture failed."
                  exit 1
              fi
              echo "Fallback database connection established."
          fi

          sudo chmod -R 777 "$STATE_DIR"

      # ═══════════════════════════════════════════════════════════════
      # STEP 2: NUCLEAR DEBLOAT — RECLAIM RAM & CPU
      # ═══════════════════════════════════════════════════════════════
      - name: Fast System Debloat (Reclaim ~2GB RAM & Time)
        run: |
          echo "::group::Fast Debloat"
          # Instead of slow purging, we stop and mask everything we don't need
          BLOAT_SERVICES=(
            "snapd" "snapd.socket" "snapd.seeded" 
            "fwupd" "ModemManager" "networkd-dispatcher" 
            "unattended-upgrades" "apt-daily.timer" "apt-daily-upgrade.timer"
            "motd-news.timer" "bluetooth" "cups" "avahi-daemon"
            "docker" "docker.socket" "containerd"
          )
          
          echo "Suppressing background noise..."
          sudo systemctl stop "${BLOAT_SERVICES[@]}" 2>/dev/null || true
          sudo systemctl disable "${BLOAT_SERVICES[@]}" 2>/dev/null || true
          sudo systemctl mask "${BLOAT_SERVICES[@]}" 2>/dev/null || true
          
          echo "Terminating persistent resource hogs..."
          sudo pkill -9 -f "snapd|docker|containerd|packagekit" || true
          
          # Quick memory flush
          sudo sync && echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
          
          echo "RAM after fast debloat:"
          free -h
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 3: INSTALL MINIMAL XFCE4 + xRDP + ESSENTIALS
      # ═══════════════════════════════════════════════════════════════
      - name: Install Minimal IceWM Desktop & xRDP (AntiX Style)
        run: |
          echo "::group::Package Installation"
          export DEBIAN_FRONTEND=noninteractive
          export NEEDRESTART_MODE=a
          
          # Using eatmydata to disable fsync during install for maximum speed
          sudo apt-get update -qq
          sudo apt-get install -y -qq eatmydata
          
          # Install IceWM + xRDP + Firefox Binary dependencies + Utilities
          # Note: Ubuntu 24.04 uses 't64' suffix for many core libraries
          sudo eatmydata apt-get install -y --no-install-recommends \
            icewm xrdp xorgxrdp x11-xserver-utils xterm zenity wget curl git htop \
            libgtk-3-0t64 libasound2t64 libdbus-glib-1-2t64 libx11-xcb1 libxcomposite1 \
            libxdamage1 libxrandr2 libxtst6 bzip2 file
          
          # Deploy Firefox Binary (Direct Download with verification)
          echo "Deploying Firefox Binary..."
          FF_URL="https://download.mozilla.org/?product=firefox-latest-ssl&os=linux64&lang=en-US"
          if curl -L "$FF_URL" -o firefox.tar.bz2; then
              if file firefox.tar.bz2 | grep -q "bzip2 compressed data"; then
                  sudo tar -xjf firefox.tar.bz2 -C /opt/
                  sudo ln -sf /opt/firefox/firefox /usr/local/bin/firefox
                  echo "Firefox binary deployed successfully."
              else
                  echo "::error::Firefox download corrupted or redirected to HTML. Check URL."
                  exit 1
              fi
          else
              echo "::error::Failed to download Firefox binary."
              exit 1
          fi
          rm -f firefox.tar.bz2
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 4: CONFIGURE xRDP & XFCE SESSION
      # ═══════════════════════════════════════════════════════════════
      - name: Configure xRDP & IceWM Runtime
        run: |
          echo "::group::RDP Configuration"
          # Configure xRDP for IceWM
          echo "icewm-session" | sudo tee /etc/skel/.xsession
          
          # Optimize xRDP performance
          sudo sed -i 's/^max_bpp=.*/max_bpp=24/' /etc/xrdp/xrdp.ini
          sudo sed -i 's/^crypt_level=.*/crypt_level=low/' /etc/xrdp/xrdp.ini
          
          # Polkit bypass (prevents password prompts for display/color)
          sudo mkdir -p /etc/polkit-1/localauthority/50-local.d/
          cat <<EOF | sudo tee /etc/polkit-1/localauthority/50-local.d/45-allow-colord.pkla
          [Allow Colord]
          Identity=unix-user:*
          Action=org.freedesktop.color-manager.create-device;org.freedesktop.color-manager.create-profile;org.freedesktop.color-manager.delete-device;org.freedesktop.color-manager.delete-profile;org.freedesktop.color-manager.modify-device;org.freedesktop.color-manager.modify-profile
          ResultAny=no
          ResultInactive=no
          ResultActive=yes
          EOF

          sudo systemctl enable xrdp
          sudo systemctl restart xrdp
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 5: PROVISION LOCAL USER ACCOUNT
      # ═══════════════════════════════════════════════════════════════
      - name: Provision RDP User & Security Groups
        run: |
          echo "::group::User Provisioning"
          # Create user with a shell
          sudo useradd -m -s /bin/bash ${{ env.RDP_USER }} || true
          echo "${{ env.RDP_USER }}:${{ env.RDP_PASS }}" | sudo chpasswd
          
          # Add to critical groups
          sudo usermod -aG sudo,ssl-cert ${{ env.RDP_USER }}
          
          # Passwordless sudo for convenience
          echo "${{ env.RDP_USER }} ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/${{ env.RDP_USER }}
          
          # Initialize IceWM config for user
          sudo -u ${{ env.RDP_USER }} mkdir -p /home/${{ env.RDP_USER }}/.icewm
          echo "icewm-session" | sudo -u ${{ env.RDP_USER }} tee /home/${{ env.RDP_USER }}/.xsession
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 6: DEPLOY PERSISTENCE SERVICES & DESKTOP TOOLS
      # ═══════════════════════════════════════════════════════════════
      - name: Deploy Persistence Services & Desktop Tools
        run: |
          echo "::group::Persistence Setup"
          STATE="/opt/state-repo"
          USER_HOME="/home/${{ env.RDP_USER }}"
          
          sudo mkdir -p "$STATE/Logs"
          sudo chown -R $USER:$(id -gn) "$STATE"
          
          # 1. Manual Backup Script
          cat <<'EOF' > "$STATE/Force-Backup.sh"
          #!/bin/bash
          STATE="/opt/state-repo"
          USER_HOME="/home/$USER"
          echo -e "\033[32mForcing Manual Backup to Remote Database (IceWM)...\033[0m"
          cd "$STATE"
          mkdir -p "$STATE/Linux/Config/icewm"
          cp -a "$USER_HOME/.icewm/"* "$STATE/Linux/Config/icewm/" 2>/dev/null || true
          mkdir -p "$STATE/Linux/Config/gtk-3.0"
          cp -a "$USER_HOME/.config/gtk-3.0/settings.ini" "$STATE/Linux/Config/gtk-3.0/" 2>/dev/null || true
          mkdir -p "$STATE/Linux/Config/shell"
          cp "$USER_HOME/.bashrc" "$STATE/Linux/Config/shell/bashrc" 2>/dev/null || true
          cp "$USER_HOME/.profile" "$STATE/Linux/Config/shell/profile" 2>/dev/null || true
          echo "Committing and Pushing to Database..."
          git add Linux/Config/
          if [ -n "$(git diff --cached --name-only)" ]; then
            git commit -m "Manual Backup (Linux-IceWM) $(date '+%H:%M:%S')"
            git push origin main
            echo -e "\033[36mBackup Sent!\033[0m"
          else
            echo -e "\033[33mNo changes detected.\033[0m"
          fi
          sleep 3
          EOF
          chmod +x "$STATE/Force-Backup.sh"

          # 2. Manual Restore Script
          cat <<'EOF' > "$STATE/Force-Restore.sh"
          #!/bin/bash
          STATE="/opt/state-repo"
          USER_HOME="/home/$USER"
          echo -e "\033[33mForcing Manual Restore from Database...\033[0m"
          cd "$STATE"
          git reset --hard HEAD
          git pull origin main --rebase --strategy-option=theirs
          echo "Restoring IceWM configuration..."
          mkdir -p "$USER_HOME/.icewm"
          cp -a "$STATE/Linux/Config/icewm/"* "$USER_HOME/.icewm/" 2>/dev/null || true
          mkdir -p "$USER_HOME/.config/gtk-3.0"
          cp "$STATE/Linux/Config/gtk-3.0/settings.ini" "$USER_HOME/.config/gtk-3.0/" 2>/dev/null || true
          cp "$STATE/Linux/Config/shell/bashrc" "$USER_HOME/.bashrc" 2>/dev/null || true
          cp "$STATE/Linux/Config/shell/profile" "$USER_HOME/.profile" 2>/dev/null || true
          echo -e "\033[36mRestore Complete!\033[0m"
          sleep 3
          EOF
          chmod +x "$STATE/Force-Restore.sh"

          # 3. Graceful Exit Script
          echo "touch /opt/state-repo/end_run.flag" > "$STATE/Finish-Session.sh"
          chmod +x "$STATE/Finish-Session.sh"

          # 4. Background Sync Daemon
          cat <<'EOF' > "$STATE/StateSync.sh"
          #!/bin/bash
          STATE="/opt/state-repo"
          LOG="$STATE/Logs/SyncAgent.log"
          USER_HOME="/home/RDPUSER_PLACEHOLDER"
          RESTORE_FLAG="/tmp/restore_done.flag"
          log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] \$1" >> "$LOG"; }
          if [ ! -f "$RESTORE_FLAG" ]; then
            cd "$STATE"
            git config user.name "Sync Agent"
            git config user.email "agent@rdp.local"
            git pull origin main --rebase --strategy-option=theirs --quiet 2>/dev/null || true
            if [ -d "$STATE/Linux/Config/icewm" ]; then
              mkdir -p "$USER_HOME/.icewm"
              cp -a "$STATE/Linux/Config/icewm/"* "$USER_HOME/.icewm/" 2>/dev/null || true
              chown -R "$(basename "$USER_HOME")":"$(basename "$USER_HOME")" "$USER_HOME/.icewm" 2>/dev/null || true
            fi
            mkdir -p "$USER_HOME/Desktop"
            cp "$STATE/Force-Backup.sh" "$USER_HOME/Desktop/"
            cp "$STATE/Force-Restore.sh" "$USER_HOME/Desktop/"
            cp "$STATE/Finish-Session.sh" "$USER_HOME/Desktop/"
            if [ -f "$STATE/Toggle-AutoShutdown.sh" ]; then cp "$STATE/Toggle-AutoShutdown.sh" "$USER_HOME/Desktop/"; fi
            chown -R "$(basename "$USER_HOME")":"$(basename "$USER_HOME")" "$USER_HOME/Desktop"
            touch "$RESTORE_FLAG"
            log "First-login restoration complete."
          fi
          while true; do
            cd "$STATE"; git pull origin main --rebase --strategy-option=theirs --quiet 2>/dev/null || true
            mkdir -p "$STATE/Linux/Config/icewm"
            cp -a "$USER_HOME/.icewm/"* "$STATE/Linux/Config/icewm/" 2>/dev/null || true
            git add Linux/Config/
            if [ -n "$(git diff --cached --name-only)" ]; then
              git commit -m "Auto-save (Linux-IceWM) $(date '+%H:%M:%S')" --quiet
              git push origin main --quiet
              log "Delta synchronized."
            fi
            sleep 300
          done
          EOF
          sed -i "s/RDPUSER_PLACEHOLDER/${{ env.RDP_USER }}/g" "$STATE/StateSync.sh"
          chmod +x "$STATE/StateSync.sh"

          cat <<EOF | sudo tee /etc/systemd/system/state-sync.service
          [Unit]
          Description=RDP State Sync Daemon
          After=network.target
          [Service]
          ExecStart=/bin/bash /opt/state-repo/StateSync.sh
          Restart=always
          User=root
          [Install]
          WantedBy=multi-user.target
          EOF
          sudo systemctl enable --now state-sync.service
          sudo chown -R "${{ env.RDP_USER }}":"${{ env.RDP_USER }}" "$STATE"
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 7: DEPLOY SAVE-RUNTIME IDLE MONITOR
      # ═══════════════════════════════════════════════════════════════
      - name: Deploy Save-Runtime Post-Login Inactivity Monitor
        if: ${{ env.SAVE_RUNTIME == 'true' }}
        run: |
          echo "::group::Idle Monitor"
          STATE="/opt/state-repo"
          IDLE_MS=$(( ${{ env.IDLE_TIMEOUT_MIN }} * 60 * 1000 ))
          cat > "$STATE/SaveRuntimeDaemon.sh" <<IDLE
          #!/bin/bash
          TIMEOUT_MS=${IDLE_MS}
          while true; do
            sleep 30
            if [ -f "/opt/state-repo/idle_disabled.flag" ]; then continue; fi
            IDLE=\$(sudo -u ${{ env.RDP_USER }} DISPLAY=:10.0 xprintidle 2>/dev/null || echo 0)
            if [ "\$IDLE" -gt "\$TIMEOUT_MS" ] 2>/dev/null; then
              sudo -u ${{ env.RDP_USER }} DISPLAY=:10.0 zenity --question --text="Idle Timeout. Shutdown in 60s?" --timeout=60 --title="Save Runtime"
              if [ \$? -ne 0 ]; then touch /opt/state-repo/end_run.flag; exit; fi
            fi
          done
          IDLE
          chmod +x "$STATE/SaveRuntimeDaemon.sh"
          cat <<EOF | sudo tee /etc/systemd/system/idle-monitor.service
          [Unit]
          Description=RDP Idle Monitor
          After=xrdp.service
          [Service]
          ExecStart=/bin/bash /opt/state-repo/SaveRuntimeDaemon.sh
          Restart=always
          User=root
          [Install]
          WantedBy=multi-user.target
          EOF
          sudo systemctl enable --now idle-monitor.service
          
          # Toggle script
          cat <<'EOF' > "$STATE/Toggle-AutoShutdown.sh"
          #!/bin/bash
          FLAG="/opt/state-repo/idle_disabled.flag"
          if [ -f "\$FLAG" ]; then
            rm -f "\$FLAG"; zenity --info --text="Auto-Shutdown ENABLED" --timeout=3
          else
            touch "\$FLAG"; zenity --warning --text="Auto-Shutdown DISABLED" --timeout=3
          fi
          EOF
          chmod +x "$STATE/Toggle-AutoShutdown.sh"
          echo "::endgroup::"

      # ═══════════════════════════════════════════════════════════════
      # STEP 8: INITIALIZE TAILSCALE MESH OVERLAY
      # ═══════════════════════════════════════════════════════════════
      - name: Initialize Secure Mesh Overlay & Protocol Routing
        env:
          TS_API: ${{ secrets.TAILSCALE_API_KEY }}
          TS_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          HOSTNAME="${{ env.RDP_USER }}-linux"
          TAILNET="${TS_TAILNET:--}"

          # Clean stray offline nodes
          if [ -n "$TS_API" ]; then
            echo "Tailscale API Key detected. Resolving stray offline nodes ($HOSTNAME)..."
            AUTH_HEADER="Authorization: Basic $(echo -n "${TS_API}:" | base64)"

            DEVICES=$(curl -s -H "$AUTH_HEADER" "https://api.tailscale.com/api/v2/tailnet/${TAILNET}/devices" 2>/dev/null || echo "{}")
            STRAY_IDS=$(echo "$DEVICES" | python3 -c "
          import sys, json
          try:
            data = json.load(sys.stdin)
            for d in data.get('devices', []):
              if d.get('hostname') == '$HOSTNAME':
                print(d['id'])
          except: pass
          " 2>/dev/null)

            if [ -n "$STRAY_IDS" ]; then
              for ID in $STRAY_IDS; do
                curl -s -X DELETE -H "$AUTH_HEADER" "https://api.tailscale.com/api/v2/device/$ID" 2>/dev/null
                echo "Orphaned node $ID terminated."
              done
            else
              echo "VPN Mesh routing is clean."
            fi
          fi

          # Install Tailscale
          curl -fsSL https://tailscale.com/install.sh | sh

          # Connect to tailnet
          sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname="$HOSTNAME"

          # Wait for IP
          TS_IP=""
          RETRIES=0
          while [ -z "$TS_IP" ] && [ "$RETRIES" -lt 24 ]; do
            RAW=$(tailscale ip -4 2>/dev/null || true)
            if echo "$RAW" | grep -q "^100\."; then
              TS_IP=$(echo "$RAW" | tr -d '[:space:]')
            else
              sleep 5
              RETRIES=$((RETRIES + 1))
            fi
          done

          if [ -z "$TS_IP" ]; then
            echo "::error::Tailscale routing failed."
            exit 1
          fi

          echo "TAILSCALE_IP=$TS_IP" >> $GITHUB_ENV

      # ═══════════════════════════════════════════════════════════════
      # STEP 9: INTERACTIVE RUNTIME & TELEMETRY STREAM
      # ═══════════════════════════════════════════════════════════════
      - name: Execute Interactive Runtime & Log Stream
        run: |
          echo "::add-mask::${{ env.RDP_PASS }}"
          echo "================ SECURE VPN ENTRY ================"
          echo "Routing IP : $TAILSCALE_IP"
          echo "Identifier : ${{ env.RDP_USER }}"
          echo "Credential : ${{ env.RDP_PASS }}"
          echo "Protocol   : RDP (port 3389)"
          echo "=================================================="
          
          LOG="/opt/state-repo/Logs/SyncAgent.log"
          END=$((SECONDS + 21000)) # 350 minutes
          LAST_LINE=0
          
          while [ $SECONDS -lt $END ]; do
            if [ -f "/opt/state-repo/end_run.flag" ]; then
              echo "[ALERT] Session termination requested."
              break
            fi
            if [ -f "$LOG" ]; then
              tail -n +$((LAST_LINE + 1)) "$LOG"
              LAST_LINE=$(wc -l < "$LOG")
            fi
            sleep 10
          done

      # ═══════════════════════════════════════════════════════════════
      # STEP 10: FINALIZE SESSION — EMERGENCY STATE SYNC
      # ═══════════════════════════════════════════════════════════════
      - name: Finalize Session Persistence & Teardown
        if: always()
        run: |
          echo "=== INITIATING EMERGENCY TEARDOWN ==="
          STATE="/opt/state-repo"
          USER_HOME="/home/${{ env.RDP_USER }}"
          
          # Kill daemons to avoid git locks
          sudo systemctl stop state-sync.service idle-monitor.service 2>/dev/null || true
          
          cd "$STATE"
          git config user.name "Emergency Agent"
          git config user.email "agent@rdp.local"

          # Final state capture
          echo "Capturing final session state..."
          mkdir -p "$STATE/Linux/Config/icewm"
          if [ -d "$USER_HOME/.icewm" ]; then
            cp -a "$USER_HOME/.icewm/"* "$STATE/Linux/Config/icewm/" 2>/dev/null || true
          fi

          mkdir -p "$STATE/Linux/Config/gtk-3.0"
          cp "$USER_HOME/.config/gtk-3.0/settings.ini" "$STATE/Linux/Config/gtk-3.0/" 2>/dev/null || true

          mkdir -p "$STATE/Linux/Config/shell"
          cp "$USER_HOME/.bashrc" "$STATE/Linux/Config/shell/bashrc" 2>/dev/null || true
          cp "$USER_HOME/.profile" "$STATE/Linux/Config/shell/profile" 2>/dev/null || true

          git add Linux/Config/
          STAGED=$(git diff --cached --name-only)
          if [ -n "$STAGED" ]; then
            echo "Changes detected, committing..."
            git commit -m "Emergency Save (Linux-IceWM) $(date '+%H:%M:%S')" --quiet
          else
            echo "No local changes detected."
          fi

          echo "Synchronizing with Database..."
          git pull origin main --rebase --strategy-option=theirs --quiet
          git push origin main --quiet
